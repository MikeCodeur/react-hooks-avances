# useLayoutEffect

### ğŸ’¡ Comprendre useLayoutEffect

## ğŸ“ Tes notes

Detaille ce que tu as appris ici
`src/exercise/04.md`ouÂ surÂ uneÂ pageÂ [Notion](https://go.mikecodeur.com/course-notes-template)

## Comprendre

`useLayoutEffect` et `useEffect` fonctionne de la mÃªme maniÃ¨re mais ne s'exÃ©cute
pas dans la mÃªme phase (cf hooks-flow). `useEffect` fonctionne de maniÃ¨re
asynchrone aprÃ¨s le rendu du navigateur. Tandis que `useLayoutEffect` va
s'exÃ©cuter de maniÃ¨re synchrone juste aprÃ¨s le chargement du DOM mais avant le
rendu du navigateur. Mais pour Ã©viter de bloquer le chargement de la page, nous
devons toujours utiliser le hook `useEffect`.

```jsx
useLayoutEffect(() => {
  //...
}, [dependances])
```

ğŸ“‘ Le lien vers
[useLayoutEffect](https://fr.reactjs.org/docs/hooks-reference.html#uselayouteffect)

## Exercice

Dans cet exercice nous allons simuler un composant qui est lent Ã  l'affichage
pour simuler un composant complexe. Ce composant est bloquant pendant 2.5
secondes.

```jsx
function ComposantLent() {
  React.useEffect(() => {
    //longue action
    const end = Date.now() + 2500
    while (Date.now() < end) {}
  })
  return null
}
```

Nous avons Ã©galement un formulaire avec un bouton `submit` qui dÃ©clenche
l'action longue. Notre objectif est de remettre le focus sur le champs input
automatiquement aprÃ¨s le clique sur le bouton (_qui nous fait perdre le focus_)

```jsx
const ref = React.useRef()

React.useEffect(() => {
  ref.current.focus()
})
```

Le comportement est un peu problÃ©matique car avec `useEffect` on est obligÃ©
d'attendre la fin du rendu global. (plus de 2.5 secondes) . Testons avec
`useLayoutEffect`

## ğŸœ Feedback

Remplir le formulaire le
[formulaire de FeedBack](https://go.mikecodeur.com/cours-react-avis).
