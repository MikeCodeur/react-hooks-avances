# useCallBack

### üí° Comprendre useCallBack

## üìù Tes notes

Detaille ce que tu as appris ici
`src/exercise/03.md`ou¬†sur¬†une¬†page¬†[Notion](https://go.mikecodeur.com/course-notes-template)

## Comprendre

`useCallBack` renvoie une fonction
[m√©mo√Øs√©](https://fr.wikipedia.org/wiki/M%C3%A9mo%C3%AFsation), c'est √† dire
stock√©e en m√©moire. Un nouvel version de la fonction sera retourn√©e si une des
entr√©es change (d√©pendances du hook). Dans l'exemple ci dessous, la fonction
`handleClick` est toujours la m√™me r√©f√©rence (ce qui optimise les performances)
sans `useCallback`, un nouvelle version serait cr√©√© √† chaque `render`.

```jsx
import * from 'react';

function MyComponent() {
  const handleClick = React.useCallback(() => {
    // handle the click event
  }, []);

  return <MyChild onClick={handleClick} />;
}
```

üìë Le lien vers la
[useCallback](https://fr.reactjs.org/docs/hooks-reference.html#usecallback)

## Exercice

Dans cet exercice tu vas devoir optimiser les hooks `useFindMarvelList` et
`useFindMarvelByName` avec `useCallBack`. Mais juste avant modifions
`useFetchData` en extrayant le terme de recheche : `search` que nous allons
d√©placer dans le `useCallback.`

> _Le param `search` a disparu car il sera contenu dans callback. callback sera
> une fonction m√©mo√Øs√© issue de `useCallback` qui retourne une Promise :
> `fetchMarvel(marvelName)`_

```jsx
function useFetchData(callback) {
  const [state, dispatch] = React.useReducer(reducer, {
    data: null,
    error: null,
    status: 'idle',
  })

  React.useEffect(() => {
    const promise = callback()
    if (!promise) {
      return
    }
    dispatch({type: 'fetching'})
    promise
      .then(marvel => dispatch({type: 'done', payload: marvel}))
      .catch(error => dispatch({type: 'fail', error}))
  }, [callback])

  return state
}
```

### 1 üöÄ Retourner un callback

Au lieu d'avoir a g√©rer de nombreuses fois le `useCallback` dans les hooks
sp√©cifiques (`useFindMarvelList` et `useFindMarvelByName`), et ex√©cuter les
appels de fonctions dans `useFetchData`, nous voudrions faire l'inverse. C'est a
dire ex√©cuter les fonctions dans les hooks sp√©cifiques et que la m√©mo√Øsation via
`useCallback` se fasse au niveau de `useFetchData`. _Au passage il faudra
d√©placer le `useEffect` dans les hooks sp√©cifiques._

Nous allons donc maintenant retourner un `callback` de `useFetchData` (que l'on
va appeler `execute`) qui sera appel√© sur le `useEffect` des hooks sp√©cifiques
comme ceci.

```jsx
function useFindMarvelList(marvelName) {
  const  {data, error, status, execute} = useFetchData()
  React.useEffect(() => {
    if (!marvelName) {
      return
    }
    execute(fetchMarvelsList(marvelName))
  }, [marvelName,execute])
  return {data, error, status}
```

Dans cet exercice tu vas devoir modifier `useFetchData` en retournant un
callback que l'on va nommer `execute` qui permet d'ex√©cuter le `fetch`.

```jsx
execute(fetchMarvelsList(marvelName))
```

## üöÄ Pour aller plus loin

Le hook `useMemo` est proche : Les deux hooks ont la signature suivante:

```jsx
useCallback(fn, deps)
useMemo(fn, deps)
```

Tous deux prennent une fonction en param√®tre et un tableau de d√©pendances. La
diff√©rence est que :

- `useCallback` n'appelle pas la fonction et retourne la fonction m√©mo√Øs√©e.
- `useMemo` ex√©cute la fonction et retourne le r√©sultat m√©mo√Øs√©

```jsx
function foo() {
  return 'bar'
}

const memoizedCallback = useCallback(foo, [])
const memoizedResult = useMemo(foo, [])

memoizedCallback
// ∆í foo() {
//   return 'bar';
// }
memoizedResult // 'bar'
memoizedCallback() // 'bar'
memoizedResult() // üî¥ TypeError
```

Doc du [hook useMemo](https://fr.reactjs.org/docs/hooks-reference.html#usememo)

## üêú Feedback

Remplir le formulaire le
[formulaire de FeedBack](https://go.mikecodeur.com/cours-react-avis).
